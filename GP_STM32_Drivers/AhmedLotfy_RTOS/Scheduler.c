/*
 * Scheduler.c
 *
 *  Created on: Oct 29, 2023
 *      Author: ahmed
 */

#include "Scheduler.h"
#include "string.h"
#include "MYRTOS_FIFO.h"

struct {
	Task_ref* OSTasks[100] ; //Scheduler Table
	unsigned int _S_MSP_Task ;
	unsigned int _E_MSP_Task ;
	unsigned int PSP_Task_Locator ;
	unsigned int NoOfActiveTasks ;
	Task_ref* CurrentTask ;
	Task_ref* NextTask ;
	enum {
		OSsuspend,
		OSRunning
	}OSmodeID;
}OS_Control;

typedef enum {
	SVC_ActivateTask,
	SVC_TerminateTask,
	SVC_TaskWaiting
}SVC_ID;

FIFO_Buf_t Ready_QUEUE ;
Task_ref* Ready_QUEUE_FIFO[100];
Task_ref MYRTOS_idleTask ;
unsigned char IdleTask_LED ;



__attribute ((naked)) void PendSV_Handler()
{
	//====================================
	//Save the Context of the Current Task
	//====================================
	//Get the Current Task "Current PSP from CPU register" as CPU Push XPSR,.....,R0
	OS_GET_PSP(OS_Control.CurrentTask->Current_PSP);

	//using this Current_PSP (Pointer) tp store (R4 to R11)
	OS_Control.CurrentTask->Current_PSP-- ;
	__asm("mov %0,r4" : "=r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP-- ;
	__asm("mov %0,r5" : "=r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP-- ;
	__asm("mov %0,r6" : "=r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP-- ;
	__asm("mov %0,r7" : "=r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP-- ;
	__asm("mov %0,r8" : "=r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP-- ;
	__asm("mov %0,r9" : "=r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP-- ;
	__asm("mov %0,r10" : "=r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP-- ;
	__asm("mov %0,r11" : "=r" (*(OS_Control.CurrentTask->Current_PSP)));

	//save the current Value of PSP
	//already saved in Current_PSP


	//====================================
	//Restore the Context of the Next Task
	//====================================
	if(OS_Control.NextTask != NULL)
	{
		OS_Control.CurrentTask = OS_Control.NextTask ;
		OS_Control.NextTask = NULL ;
	}
	__asm("mov r11,%0" : : "r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP++ ;
	__asm("mov r10,%0" : : "r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP++ ;
	__asm("mov r9,%0" : : "r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP++ ;
	__asm("mov r8,%0" : : "r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP++ ;
	__asm("mov r7,%0" : : "r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP++ ;
	__asm("mov r6,%0" : : "r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP++ ;
	__asm("mov r5,%0" : : "r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP++ ;
	__asm("mov r4,%0" : : "r" (*(OS_Control.CurrentTask->Current_PSP)));
	OS_Control.CurrentTask->Current_PSP++ ;

	//Update PSP and exit
	OS_SET_PSP(OS_Control.CurrentTask->Current_PSP);
	__asm("BX LR");


}


void MYRTOS_IdleTask()
{
	while (1)
	{
		//		The "wfi" (Wait For Interrupt) instruction is used to put the processor into a low-power state until an interrupt is received. An exception is a type of interrupt, but it is not the same as the interrupt that "wfi" is waiting for. Exceptions are typically caused by events such as illegal instruction execution, divide-by-zero, or memory access violation, and are typically handled by the processor's exception handler.
		//
		//		"wfi" instruction only waits for external interrupts which are generated by peripherals or external events and not the exceptional interrupts which are generated by the CPU itself.
		//
		//		In general, when you want to wait for any type of interrupt, you can use the "wfi" instruction, but if you want to wait for a specific event, you would use the "wfe" instruction, as it allows you to wait for a specific event, rather than any interrupt.
		//
		IdleTask_LED ^= 1 ;
		__asm("wfe") ;
	}
}


void MYRTOS_Create_MainStack()
{
	OS_Control._S_MSP_Task = &_estack ;

	//Aligned 8 Bytes spaces between Main Task and PSP tasks
	OS_Control._E_MSP_Task = OS_Control._S_MSP_Task - MainStackSize ;

	OS_Control.PSP_Task_Locator = (OS_Control._E_MSP_Task - 8);

	// if (_E_MSP_Task < _&eheap) Error : Exceeded the available stack size
}



MYRTOS_ErrorID MYRTOS_Init()
{
	MYRTOS_ErrorID error = NoError ;

	//Update OS Mode (OS Suspend)
	OS_Control.OSmodeID = OSsuspend ;

	//Specify the Main Stack For OS
	MYRTOS_Create_MainStack();

	//Create OS Ready Queue
	if (FIFO_init(&Ready_QUEUE,Ready_QUEUE_FIFO, 100) != FIFO_NO_ERROR )
	{
		error += Ready_Queue_init_error ;
	}

	//Configure Idle Task
	strcpy(MYRTOS_idleTask.TaskName,"IdleTask");
	MYRTOS_idleTask.priority = 255 ;
	MYRTOS_idleTask.p_TaskEntry = MYRTOS_IdleTask ;
	MYRTOS_idleTask.Stack_Size = 300 ;


	error += MYRTOS_CreateTask(&MYRTOS_idleTask);

	return error ;
}






void MYRTOS_Create_Task_Stack(Task_ref* Tref)
{
	/*Task Frame
	 * ======
	 * XPSR
	 * PC (Next Task Instruction which should be Run)
	 * LR (return register which is saved in CPU while Task1 running before TaskSwitching)
	 * r12
	 * r4
	 * r3
	 * r2
	 * r1
	 * r0
	 *====
	 *r5, r6 , r7 ,r8 ,r9, r10,r11 (Saved/Restore)Manual
	 */

	Tref->Current_PSP = Tref->_S_PSP_Task ;

	Tref->Current_PSP-- ;
	*(Tref->Current_PSP) = 0x01000000;         //DUMMY_XPSR should T =1 to avoid BUS fault;//0x01000000

	Tref->Current_PSP-- ;
	*(Tref->Current_PSP) = (unsigned int)Tref->p_TaskEntry ; //PC

	Tref->Current_PSP-- ; //LR = 0xFFFFFFFD (EXC_RETURN)Return to thread with PSP
	*(Tref->Current_PSP)  = 0xFFFFFFFD ;

	for (int  j=0 ; j< 13 ; j++ )
	{
		Tref->Current_PSP-- ;
		*(Tref->Current_PSP)  = 0 ;

	}

}

MYRTOS_ErrorID MYRTOS_CreateTask(Task_ref* Tref )
{
	MYRTOS_ErrorID error = NoError ;

	//Create Its OWN PSP stack
	//Check task size exceeded the PSP stack
	Tref->_S_PSP_Task = OS_Control.PSP_Task_Locator ;
	Tref->_E_PSP_Task = Tref->_S_PSP_Task - Tref->Stack_Size ;

	//	-				-
	//	- _S_PSP_Task	-
	//	-	Task Stack	-
	//	- _E_PSP_Task	-
	//	-				-
	//	- _eheap		-
	//	-				-
	//

	//	if (Tref->_E_PSP_Task < (unsigned int)(&(_eheap)))
	//	{
	//		return Task_exceeded_StackSize ;
	//	}

	//Aligned 8 Bytes spaces between Task PSP and Other
	OS_Control.PSP_Task_Locator = (Tref->_E_PSP_Task - 8) ;

	//Initialize PSP Task Stack
	MYRTOS_Create_Task_Stack(Tref);

	//Update Scheduler table
	OS_Control.OSTasks[OS_Control.NoOfActiveTasks]= Tref ;
	OS_Control.NoOfActiveTasks++ ;

	//Task State Update -> Suspend
	Tref->TaskState = Suspend ;

	return error ;
}

//Handler mode
void bubbleSort()
{
	unsigned int i, j , n;
	Task_ref* temp ;
	n = OS_Control.NoOfActiveTasks ;
	for (i = 0; i < n - 1; i++)

		// Last i elements are already in place
		for (j = 0; j < n - i - 1; j++)
			if (OS_Control.OSTasks[j]->priority > OS_Control.OSTasks[j + 1]->priority)
			{
				temp = OS_Control.OSTasks[j] ;
				OS_Control.OSTasks[j] = OS_Control.OSTasks[j + 1 ] ;
				OS_Control.OSTasks[j + 1] = temp ;
			}

}

//Handler mode
void MYRTOS_Update_Schadule_Tables()
{
	Task_ref* temp = NULL ;
	Task_ref* Ptask ;
	Task_ref* PnextTask ;
	int i = 0 ;

	//1- bubble sort SchTable OS_Control-> OSTASKS[100] (priority high then low)
	bubbleSort();

	//2- free Ready Queue
	while(FIFO_dequeue(&Ready_QUEUE, &temp /*pointer to pointer*/)!=FIFO_EMPTY);

	//3- update ready queue
	while(i< OS_Control.NoOfActiveTasks)
	{
		Ptask = OS_Control.OSTasks[i] ;
		PnextTask = OS_Control.OSTasks[i+1] ;
		if (Ptask->TaskState != Suspend)
		{
			//In case of reaching to the end of available OSTASKS
			if (PnextTask->TaskState == Suspend)
			{
				FIFO_enqueue(&Ready_QUEUE, Ptask);
				Ptask->TaskState = ready ;
				break ;
			}
			//If Ptask Priority > PnextTask Priority then (lowest number is meaning higher priority)
			if (Ptask->priority < PnextTask->priority )
			{
				FIFO_enqueue(&Ready_QUEUE, Ptask);
				Ptask->TaskState = ready ;
				break ;
			}
			else if (Ptask->priority == PnextTask->priority)
			{
				//if the Ptask priority == PnextTask Priority then
				//Push Ptask to ready state
				//make the Ptask = PnextTask and PnextTask++
				FIFO_enqueue(&Ready_QUEUE, Ptask);
				Ptask->TaskState = ready ;
			}
			else if (Ptask->priority > PnextTask->priority)
			{
				//Not allowed to happen as we already reordered it by bubble sort
				break ;
			}
		}


		i++ ;
	}

}

//Handler mode
void Decide_WhatNext()
{
	//If Ready Queue is empty && OS_Control->currentTask != suspend
	if (Ready_QUEUE.counter == 0 && OS_Control.CurrentTask->TaskState != Suspend) //FIFO_EMPTY
	{
		OS_Control.CurrentTask->TaskState = Running ;
		//Add the current task again(round robin)
		FIFO_enqueue(&Ready_QUEUE, OS_Control.CurrentTask);
		OS_Control.NextTask = OS_Control.CurrentTask ;
	}
	else
	{
		FIFO_dequeue(&Ready_QUEUE, &OS_Control.NextTask);
		OS_Control.NextTask->TaskState = Running ;
		//Update Ready queue (to keep round robin Algorithm happen)
		if ((OS_Control.CurrentTask->priority == OS_Control.NextTask->priority )&&(OS_Control.CurrentTask->TaskState != Suspend))
		{
			FIFO_enqueue(&Ready_QUEUE, OS_Control.CurrentTask);
			OS_Control.CurrentTask->TaskState = ready ;
		}
	}
}


//Handler mode
void OS_SVC(int* StackFramePointer)
{
	//OS_SVC_Set stack start found in -> r0 , r0 is pointed by StackFramePointer
	//OS_SVC_Set stack : r0,r1,r2,r12,LR,PC,XPSR

	unsigned char SVC_number ;

	SVC_number = *((unsigned char*)(((unsigned char*)StackFramePointer[6])-2)) ;

	switch(SVC_number)
	{
	case SVC_ActivateTask :
	case SVC_TerminateTask :
		//Update Scheduler Table , Ready Queue
		MYRTOS_Update_Schadule_Tables();
		//OS is in Running State
		if (OS_Control.OSmodeID == OSRunning)
		{
			if (strcmp(OS_Control.CurrentTask->TaskName,"IdleTask") != 0)
			{
				//Decide What Next
				Decide_WhatNext();

				//Trigger OS_PendSV (Switch Context/ Restore)
				trigger_OS_PendSV();
			}
		}


		break ;
	case SVC_TaskWaiting :
		//Update Scheduler Table , Ready Queue
		MYRTOS_Update_Schadule_Tables();
		break ;
	}

}

//Thread mode
void MYRTOS_OS_SVC_Set(SVC_ID ID)
{
	switch(ID)
	{
	case SVC_ActivateTask :
		__asm("svc #0x00");

		break ;
	case SVC_TerminateTask :
		__asm("svc #0x01");

		break ;
	case SVC_TaskWaiting :
		__asm("svc #0x02");

		break ;
	}
}


void MYRTOS_ActivateTask(Task_ref* Tref)
{
	Tref->TaskState = Waiting ;
	MYRTOS_OS_SVC_Set(SVC_ActivateTask);
}
void MYRTOS_TerminateTask(Task_ref* Tref)
{
	Tref->TaskState = Suspend ;
	MYRTOS_OS_SVC_Set(SVC_TerminateTask);

}


void MYRTOS_TaskWait(unsigned int NoTicks ,Task_ref* SelfTref)
{
	SelfTref->TimingWaiting.Blocking = Enable ;
	SelfTref->TimingWaiting.Ticks_Count = NoTicks ;

	//Task Should Be Blocked
	SelfTref->TaskState = Suspend ;

	//To be Suspend Immediately
	MYRTOS_OS_SVC_Set(SVC_TerminateTask);
}

void MYRTOS_StartOS()
{
	OS_Control.OSmodeID = OSRunning ;

	//Set Default "Current Task = Idle Task"
	OS_Control.CurrentTask = &MYRTOS_idleTask ;

	//Activate Idle Task
	MYRTOS_ActivateTask(&MYRTOS_idleTask);

	//Start my timer (ticker)
	Start_Ticker(); //1ms

	OS_SET_PSP(OS_Control.CurrentTask->Current_PSP);

	//Switch Thread mode SP from MSP to PSP
	OS_SWITCH_SP_TO_PSP;
	SWITCH_CPU_AccessLevel_UNPRIVILEGED;
	MYRTOS_idleTask.p_TaskEntry();
}


void MYRTOS_Update_TaskWaiting_Time()
{
	int i ;
	for (i = 0 ; i < OS_Control.NoOfActiveTasks ; i++)
	{
		if ((OS_Control.OSTasks[i]->TaskState == Suspend) && (OS_Control.OSTasks[i]->TimingWaiting.Blocking == Enable ))
		{
			OS_Control.OSTasks[i]->TimingWaiting.Ticks_Count-- ;

			if(OS_Control.OSTasks[i]->TimingWaiting.Ticks_Count == 0)
			{
				OS_Control.OSTasks[i]->TimingWaiting.Blocking = Disable ;
				OS_Control.OSTasks[i]->TaskState = Waiting ;
				MYRTOS_OS_SVC_Set(SVC_TaskWaiting);
			}
		}
	}
}

MYRTOS_ErrorID MYRTOS_AquireMutex(Mutex_ref* Mref ,Task_ref* Tref)
{
	if(Mref->CurrentTUser == NULL) //Not Taken By Any Task
	{
		Mref->CurrentTUser = Tref ;
	}
	else
	{
		if (Mref->NextTUser == NULL) //Not Pending Request By Any Task
		{
			Mref->NextTUser = Tref;
			//Move To Suspend State Until The Other Task Release The Mutex
			Tref->TaskState = Suspend ;
			MYRTOS_OS_SVC_Set(SVC_TerminateTask);
		}
		else //More Then Two Tasks Want The Same Mutex In The Same Time
		{
			return MutexIsReachedToMaxNumberOfUsers ;
		}
	}

	return NoError ;
}
void MYRTOS_ReleaseMutex(Mutex_ref* Mref)
{
	if(Mref->CurrentTUser != NULL) // There is a Task to be released
	{
		Mref->CurrentTUser = Mref->NextTUser ;
		Mref->NextTUser = NULL ;
		Mref->CurrentTUser->TaskState = Waiting ;
		MYRTOS_OS_SVC_Set(SVC_ActivateTask);
	}

}



